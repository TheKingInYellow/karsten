#!/usr/bin/python
"""

Plotting functions for meshes, point particles and particle tracks generated by
telemac-parse, prepmesh, floaters etc

Will plot 2D or 3D meshes, with or without point particle locations and tracks
Paths taken from .ini file used with prepmesh/floaters
"""

import numpy

from matplotlib import pyplot
from matplotlib.tri import Triangulation
from mpl_toolkits.mplot3d import axes3d

def plot_mesh_2D(conf, axes=None, meshcolour="grey", pointcolour=None, pointmarker=None):
    """
    Plot 2D mesh, using connectivity information as triangulation
    Will create new figure and axes if not supplied

    Returns axes
    """

    if not axes:
        fig = pyplot.figure()
        axes = fig.add_subplot(111)

    x = numpy.loadtxt("%s.x.txt" % conf.basename, usecols=[1], skiprows=1)
    y = numpy.loadtxt("%s.y.txt" % conf.basename, usecols=[1], skiprows=1)
    conn = numpy.loadtxt("%s.conn.txt" % conf.basename, dtype=numpy.int32)

    nelem, ndp = conn[0]
    conn = conn[1:]
    elN2 = conn[...,1]

    tri = []
    for i in numpy.split(elN2, nelem):
        tri.append(i)

    t = Triangulation(x, y, triangles=tri)

    axes.triplot(t, color=meshcolour)
    if not (pointcolour == None and pointmarker == None):
        if not pointcolour:
            pointcolour = "blue"

        if not pointmarker:
            pointmarker = "o"

        axes.scatter(x, y, color=pointcolour, marker=pointmarker)

    return axes

def plot_ids_2D(conf, axes=None, labelcolour="red", offset=0.05):
    """
    Plot node IDs for a 2D mesh

    Will create new figure and axes if not supplied

    Returns axes
    """
    if not axes:
        fig = pyplot.figure()
        axes = fig.add_subplot(111)

    x = numpy.loadtxt("%s.x.txt" % conf.basename, usecols=[1], skiprows=1)
    y = numpy.loadtxt("%s.y.txt" % conf.basename, usecols=[1], skiprows=1)

    for i in range(len(x)):
        axes.annotate("%d" % i, (x[i], y[i]), xytext=(x[i]+offset, y[i]+offset), color=labelcolour)
    return axes

def plot_particles_2D(conf, pfile, axes=None, labels=True, marker="x", markercolour="blue", labelcolour="blue", offset=0.1):
    """
    Plot initial particle positions

    Defaults to labelled markers
    Will create new figure and axes if not supplied

    Returns axes
    """

    if not axes:
        fig = pyplot.figure()
        axes = fig.add_subplot(111)

    p = numpy.asarray([x.position for x in pfile.particles])
    axes.scatter(p[:, 0], p[:, 1], marker=marker, color=markercolour)
    if labels:
        for i in range(len(p)):
            axes.annotate("%d" % i, (p[i, 0], p[i, 1]),
                    xytext=(p[i, 0], p[i, 1]+offset), color=labelcolour)
    return axes

def plot_tracks_2D(conf, axes=None, marker=""):
    """
    Plot particle tracks

    Defaults to lines without marked points
    Will create new figure and axes if not supplied

    Returns axes
    """
    if not axes:
        fig = pyplot.figure()
        axes = fig.add_subplot(111)

    trackfile = "%s/%s.tracks.txt" % (conf.outputpath, conf.basefilename)
    with open(trackfile, 'r') as f:
        line = f.readline().partition("\t")
        if (line[1] == "" and line[2] == ""):
            print "Invalid header encountered in track file"
            return None

        pc = int(line[0])
        ts = int(line[2])
    p = numpy.loadtxt(trackfile, usecols=[0, 1, 2, 3], skiprows=1)
    # p = [[id, t, x, y], [id, t, x, y], ...]
    p2x = []
    p2y = []
    for i in range(0, pc-1):
        p2x.append([x[2] for x in p if x[0] == i ])
        p2y.append([x[3] for x in p if x[0] == i ])

    for i in range(0, pc-1):
        xp = p2x[i]
        yp = p2y[i]
        axes.plot(xp, yp, marker=marker)
    return axes

def plot_mesh_3D(conf, axes=None, meshstyle=":", meshcolour=None, pointcolour=None, pointmarker=None, time=0):
    """
    Plot 3D mesh, using connectivity information to build elements
    Will create new figure and axes if not supplied

    Returns axes
    """

    if not axes:
        fig = pyplot.figure()
        axes = axes3d.Axes3D(fig)
        axes.set_xlabel("X")
        axes.set_ylabel("Y")
        axes.set_zlabel("Z")

    x = numpy.loadtxt("%s.x.txt" % conf.basename, usecols=[1], skiprows=1)
    y = numpy.loadtxt("%s.y.txt" % conf.basename, usecols=[1], skiprows=1)
    z = numpy.loadtxt("%s.var%d.t%d.txt" % (conf.basename, conf.z, time), usecols=[1])

    conn = numpy.loadtxt("%s.conn.txt" % conf.basename, dtype=numpy.int32)
    nelem, ndp = conn[0]
    conn = conn[1:]
    elN2 = conn[...,1]
    for i in numpy.split(elN2, nelem):
        elCoords = [[x[k], y[k], z[k]] for k in i]
        elX = [e[0] for e in elCoords]
        elY = [e[1] for e in elCoords]
        elZ = [e[2] for e in elCoords]

        if meshcolour:
            axes.plot(elX, elY, elZ, linestyle=meshstyle, color=meshcolour)
        else:
            axes.plot(elX, elY, elZ, linestyle=meshstyle)


        if not (pointcolour == None and pointmarker == None):
            if not pointcolour:
                pointcolour = "blue"

            if not pointmarker:
                pointmarker = "o"

            axes.plot(elX, elY, elZ, color=pointcolour, marker=pointmarker, linestyle=" ")

    return axes

def plot_ids_3D(conf, axes=None, labelcolour="red", offset=0.05, time=0):
    """
    Plot node IDs for a 3D mesh

    Will create new figure and axes if not supplied

    Returns axes
    """
    if not axes:
        fig = pyplot.figure()
        axes = axes3d.Axes3D(fig)
        axes.set_xlabel("X")
        axes.set_ylabel("Y")
        axes.set_zlabel("Z")

    x = numpy.loadtxt("%s.x.txt" % conf.basename, usecols=[1], skiprows=1)
    y = numpy.loadtxt("%s.y.txt" % conf.basename, usecols=[1], skiprows=1)
    z = numpy.loadtxt("%s.var%d.t%d.txt" % (conf.basename, conf.z, time), usecols=[1])

    for i in range(len(x)):
        axes.text(x[i]+offset, y[i]+offset, z[i]+offset, "%d" % i, color=labelcolour)
    return axes

def plot_particles_3D(conf, pfile, axes=None, labels=True, marker="x", labelcolour="blue", offset=0.1):
    """
    Plot initial particle positions in 3D

    Defaults to labelled markers
    Will create new figure and axes if not supplied

    Returns axes
    """

    if not axes:
        fig = pyplot.figure()
        axes = axes3d.Axes3D(fig)
        axes.set_xlabel("X")
        axes.set_ylabel("Y")
        axes.set_zlabel("Z")

    p = numpy.asarray([x.position for x in pfile.particles])
    axes.plot(p[:, 0], p[:, 1], p[:, 2], marker=marker, linestyle="")
    if labels:
        for i in range(len(p)):
            axes.text(p[i, 0], p[i, 1], p[i, 2], "%d" % i, color=labelcolour)
    return axes



def plot_tracks_3D(conf, axes=None, marker=" ", linestyle='--'):
    """
    Plot particle tracks in 3D

    Defaults to lines without marked points
    Will create new figure and axes if not supplied

    Returns axes
    """

    if not axes:
        fig = pyplot.figure()
        axes = axes3d.Axes3D(fig)
        axes.set_xlabel("X")
        axes.set_ylabel("Y")
        axes.set_zlabel("Z")

    trackfile = "%s/%s.tracks.txt" % (conf.outputpath, conf.basefilename)
    with open(trackfile, 'r') as f:
        line = f.readline().partition("\t")
        if (line[1] == "" and line[2] == ""):
            print "Invalid header encountered in track file"
            return None

        pc = int(line[0])
        ts = int(line[2])
    p = numpy.loadtxt(trackfile, usecols=[0, 1, 2, 3, 4], skiprows=1)
    # p = [[id, t, x, y, z], [id, t, x, y, z], ...]
    p2x = []
    p2y = []
    p2z = []
    for i in range(0, pc-1):
        p2x.append([x[2] for x in p if x[0]==i])
        p2y.append([x[3] for x in p if x[0]==i])
        p2z.append([x[4] for x in p if x[0]==i])

    for i in range(0, pc-1):
        xp = p2x[i]
        yp = p2y[i]
        zp = p2z[i]
        axes.plot(xp, yp, zp, marker=marker, linestyle=linestyle)

    return axes
